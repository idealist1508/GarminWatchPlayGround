syntax = "proto2";
package GDI.Proto.ConnectIQHTTP;

import "GDIDataTypes.proto";

option java_package = "com.garmin.proto.generated";
option java_outer_classname = "GDIConnectIQHTTPProto";
option optimize_for = LITE_RUNTIME;

message ConnectIQHTTPService {
    optional ConnectIQHTTPRequest connect_iq_http_request = 1;
    optional ConnectIQHTTPResponse connect_iq_http_response = 2;
    optional ConnectIQImageRequest connect_iq_image_request = 3;
    optional ConnectIQImageResponse connect_iq_image_response = 4;
    optional RawResourceRequest raw_resource_request = 5;
    optional RawResourceResponse raw_resource_response = 6;
    optional ConnectIQOAuthRequest connect_iq_oauth_request = 7;
    optional ConnectIQOAuthResponse connect_iq_oauth_response = 8;
    optional ConnectIQOAuthCompleteRequest connect_iq_oauth_complete_request = 9;
    optional ConnectIQOAuthCompleteResponse connect_iq_oauth_complete_response = 10;
    optional OpenWebpageRequest open_webpage_request = 11;
    optional OpenWebpageResponse open_webpage_response = 12;
}

message ConnectIQHTTPRequest {
    enum HTTPMethod {
        UNKNOWN = 0;
        GET = 1;
        PUT = 2;
        POST = 3;
        DELETE = 4;
    }
    enum ResponseType {
        JSON = 0;
        URL_ENCODED = 1;
        PLAIN_TEXT = 2;
        XML = 3;
    }
    enum Version {
        VERSION_1 = 0;
        VERSION_2 = 1;
    }
    required string url = 1;
    optional HTTPMethod http_method = 2;  // Must be set
    optional bytes http_header_fields = 3;  // Default value is the default header fields generated by the mobile OS
    optional bytes http_body = 4;  // Serialized Connect IQ data that GCM will convert to JSON and set as HTTP body
    optional uint32 max_response_length = 5;  // The maximum combined length of http_body and http_header_fields in response.
                                              // Default value is no max response length.
    optional bool include_http_header_fields_in_response = 6 [default = true];
    optional bool compress_response_body = 7 [default = false]; // Flag to allow compressed json responses, assuming the device has the right tvm version. Default to false in the case it doesn't.
    optional ResponseType response_type = 8; // This value is only used for a VERSION_2 message. If it's not provided we'll use the "Content-Type" header value to attempt to determine the server response's content type.
    optional Version version = 9 [default = VERSION_1]; // The version of this message
}

message ConnectIQHTTPResponse {
    enum ResponseStatus {
        UNKNOWN = 0;
        OK = 100;
        INVALID_HTTP_HEADER_FIELDS_IN_REQUEST = 200;
        INVALID_HTTP_BODY_IN_REQUEST = 201;
        INVALID_HTTP_METHOD_IN_REQUEST = 202;
        NETWORK_REQUEST_TIMED_OUT = 300;
        INVALID_HTTP_BODY_IN_NETWORK_RESPONSE = 400;
        INVALID_HTTP_HEADER_FIELDS_IN_NETWORK_RESPONSE = 401;
        NETWORK_RESPONSE_TOO_LARGE = 402;
        INSECURE_REQUEST = 1001;
    }
    optional ResponseStatus status = 1;  // Must be set
    optional int32 http_status_code = 2;  // Will be set if status is OK
    optional bytes http_body = 3;  // Serialized Connect IQ data that is converted from JSON by GCM.  Will be set if status is OK and the web service response contains an HTTP body with JSON data.
    optional bytes http_header_fields = 4;  // Serialized Connect IQ data that will be set if status is OK and include_http_header_fields_in_response is true.
    optional uint32 inflated_size = 5; // Will be set to 0 if not deflated, otherwise size of compresseddata.
    optional ConnectIQHTTPRequest.ResponseType response_type = 6; // The value passed in the request will be set here
}

message ConnectIQImageRequest {
    enum Dithering {
        NONE = 0;
        FLOYD_STEINBERG = 1;
    }

    required string url = 1;  // URL of an image file
    required uint32 partNumber = 2;  // The part number of the device making the request. This should match one found in the devices.xml
    optional uint32 max_width = 3;  // If necessary the image will be scaled preserving aspect ratio to fit within max width specified
    optional uint32 max_height = 4;  // If necessary the image will be scaled preserving aspect ratio to fit within max height specified
    optional uint32 max_size = 5;  // The maximum size in bytes of the image after it has been converted for display on the device
    optional bytes palette = 6; // The color palette to dither the image with.
    optional Dithering dithering = 7; // The dithering to use when processing the image. If not present default to Floyd-Steinberg.
}

message ConnectIQImageResponse {
    enum ResponseStatus {
        UNKNOWN = 0;
        OK = 100;
        NETWORK_REQUEST_TIMED_OUT = 200;
        IMAGE_TOO_LARGE = 300;
    }
    optional ResponseStatus status = 1;  // Must be set
    optional int32 http_status_code = 2;  // Will be set if status is OK
    optional bytes image_data = 3;  // Image data converted for display on the device.  The format is proprietary for Garmin devices and includes meta-data in addition to a bitmap.  Will be set if status is OK.
    optional uint32 width = 4; // Will be set if status is OK
    optional uint32 height = 5; // Will be set if status is OK
    optional uint32 inflated_size = 6; // Will be set if status is OK
}

message RawResourceRequest {
    enum HTTPMethod {
        UNKNOWN = 0;
        GET = 1;
        PUT = 2;
        POST = 3;
        DELETE = 4;
    }
    message HTTPHeader {
        required string key = 1;
        required string value = 2;
    }
    required string url = 1;  // URL of a resource
    optional uint32 max_size = 2;  // The maximum size in bytes of the file. Only valid if set and non-zero.
    optional HTTPMethod method = 3 [default = GET];
    optional string body = 4;
    repeated HTTPHeader headers = 5;
    optional bool use_data_xfer = 6;

    optional bytes raw_body = 7; // May be provided in place of body, when a byte array is required instead of a UTF-8 string payload.
}

message RawResourceResponse {
    enum ResponseStatus {
        UNKNOWN = 0;
        OK = 100;
        NETWORK_REQUEST_TIMED_OUT = 200;
        FILE_TOO_LARGE = 300;
    }
    optional ResponseStatus status = 1;  // Must be set
    optional int32 http_status_code = 2;  // Will be set if status is OK
    optional bytes resource_data = 3;  // Raw resource data. Will be set if status is OK.
    optional GDI.Proto.DataTypes.DataTransferItem xfer_data = 4;
}

message ConnectIQOAuthRequest {
    enum ResultFormat {
        URL = 0; // The result will be URL encoded into the result URL
        BODY_JSON = 1; // The result will be included as JSON in the body
    }

    required string initial_url = 1; // The initial URL to load into the webview.
    optional bytes initial_url_parameters = 2; // Query string parameters to add to the initial URL. This is a Monkey C serialized hash.
    optional bool parameters_encrypted = 3; // If the parameters serialized hash is encrypted. Defaults to false
    optional bool parameters_compressed = 4; // If the parameters serialized hash is compressed. Defaults to false
    required string result_url = 5; // The URL which will be loaded when the Oauth process is complete (Connect Mobile will trigger a response off this).
    optional ResultFormat result_type = 6; // The format of the response. If this isn't provided then ResultFormat.URL will be used.
    optional bytes result_keys = 7; // A serialized Monkey C hash. The keys to look for in the response. The values associated with these keys will be returned in the ConnectIQOauthResponse message. If this isn't provided then nothing is returned.
    optional string app_name = 8; // The regionalized name of the app
    required bytes app_uuid = 9; // The UUID of the app. This is a byte array from TVM. It shouldn't be messed with.
}

message ConnectIQOAuthResponse {
    enum ResponseStatus {
        UNKNOWN = 0;
        OK = 1;
        BAD_REQUEST = 2; // The information provided in the request isn't sufficient to start the OAuth process
        NOTIFICATION_FAILURE = 3; // A problem occurred notifiying the user they need to sign in (couldn't push notification, etc)
    }

    required ResponseStatus status = 1; // The status of processing the request.
}

message ConnectIQOAuthCompleteRequest {
    enum ResponseStatus {
        UNKNOWN = 0;
        OK = 1;
        WEB_REQUEST_ERROR = 2;
    }

    required ResponseStatus status = 1; // The status of the Oauth call/sign in process
    optional int32 http_status_code = 2; // Response code from the final page of the OAuth flow
    required bytes app_uuid = 3; // The UUID of the app. This is a byte array from TVM.
    optional bytes data = 4; // The keys specified in the request along with their associated values in the form of a serialized Monkey C hash.
    optional bool encrypted = 5; // If the data block is encrypted. If this isn't present the assumption is that the data block isn't incrypted.
    optional bool compressed = 6; // If the data block is compressed. If this isn't present the assumption is that the data block isn't compressed.
}

message ConnectIQOAuthCompleteResponse {
    enum ResponseStatus {
        UNKNOWN = 0;
        OK = 1;
    }

    required ResponseStatus status = 1;
}

message OpenWebpageRequest {
    required string url = 1;      // The URL to load
    optional bytes params = 2;    // A serialized Monkey C hash or key value URL parameters
    optional string app_name = 3; // The regionalized name of the app
}

message OpenWebpageResponse {
    enum ResponseStatus {
        UNKNOWN = 0;
        OK = 1;
        BAD_REQUEST = 2;          // The information in the request isn't sufficient to open a web page
        NOTIFICATION_FAILURE = 3; // A problem occurred notifying the user a web page needs to be opened
    }
    required ResponseStatus status = 1;
}
